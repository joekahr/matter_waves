<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Matter Waves</title>

        <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
        <meta name="description" content="Matter Waves">
        <meta name="author" content="joekahr@gmail.com">
        <meta name="generator" content="J. Kahr">
        <meta name="version" content="7.3">
        <meta name="viewport" content="width=device-width,user-scalable=0,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0">
	
        <style type="text/css">
			canvas{background-color:#000000; overflow:hidden}
			body  {margin:0;padding:0}
			td {height:12px; width:100px; padding:0px}
			th, tr {height:12px; padding:0px}
        </style>
    </head>

    <body onload="load();" onresize="resize(false);" style="background-color:rgb(0,0,0);">

        <canvas id="canvas" oncontextmenu="return false;" style="background-color:rgba(0, 0, 0, 0); position:absolute; z-index:2; visibility:hidden;"></canvas>
        
		<div id="start" style="text-align:center; background-color:rgb(0,0,0); position:absolute; width:100%; height:100%; left:0%; top:0px; visibility:visible;">
<!-- 			<br>
			<button id="dblslit_button" type="button" style="text-align:center; background-color:rgb(0,255,0);">Light Waves</button>
			<br> -->
			<br>
			<button id="free_button" type="button" style="text-align:center; background-color:rgb(0,255,0);">Free Particle</button>
			<br><br><br>
			<button title="Matter Waves App Description" type="button" id="description_button" style="text-align:center; font-weight:bold">Description</button>
			<br><br><br>
      		<button title="Mouse and Touch Screen Controls" type="button" id="UI_button" style="text-align:center; font-weight:bold">User Interface Help</button>
        </div>

        <div id="description" style="font-family:Cambria,Math; text-align:left; background-color:rgb(0,0,0); color:rgb(255,255,255); position:absolute; width:100%; top:0px; padding:0px; border-width:0px; margin:0px; min-width:300px; z-index:2; visibility:hidden">
        	<br>
      		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<button type="button" id="return_from_description" style="font-weight:bold; position:center;">RETURN</button><br>
      		<br>
      		This interactive animation is based on John Macken's treatment of matter waves.<br>
      		<br>
      		Same as Macken:<br>
		  	<ul>
		    	<li>outgoing and incoming waves sum to create de Broglie waves</li>
		    	<li>waves have real-value amplitudes that do not decrease with distance</li>
		    	<li>corresponding outgoing and incoming waves have opposite sign</li>
		    	<li>time and distance scales are set to make standing and deBroglie waves visible</li>
		  		<li>particle has an oscillator at its core with proper frequency = mc&sup2;/h</li>
		    	<li>standing waves at v = 0 have Compton wavelength and frequency</li>
		    	<li>oscillator frequency at v > 0 is slowed by Lorentz factor &gamma;</li>
		    	<li>blue depicts positive amplitude, yellow depicts negative amplitude</li>
		  	</ul>
		  	<div style="margin:30px;">
			Macken references:<br>
			&nbsp;&nbsp;&nbsp;<a style="color:white" href="http://onlyspacetime.com/">John Macken's website</a><br>
			&nbsp;&nbsp;&nbsp;<a style="color:white" href="http://onlyspacetime.com/OnlySpacetime.pdf"><b>The Universe is Only Spacetime</b></a> John Macken's online book<br>
		  	&nbsp;&nbsp;&nbsp;<a style="color:white" href="http://onlyspacetime.com/SPIE_New_Aether_2015.pdf">Energetic Spacetime: The New Aether (see Figures 5A, 5B, 5C)</a><br>
		  	&nbsp;&nbsp;&nbsp;<a style="color:white" href="https://www.youtube.com/@Oscillatingspace-time">Oscillating space-time: The foundation of Universe</a> John Macken's YouTube channel<br>
			&nbsp;&nbsp;&nbsp;<a style="color:white" href="https://www.scirp.org/journal/paperinformation?paperid=134527">Journal of Modern Physics article</a> and 
			<a style="color:white" href="https://www.quantizedwave.com/video">video for the article</a><br>
			</div>
		  	<br><br>
		  	Different from Macken:<br>
		  	<ul>
		  		<li>oscillator generates both <font color='lime'>retarded</font> (forward-in-time) and <font color='red'>advanced</font> (backward-in-time) waves</li>
		  		<li>viewed in normal time: <font color='lime'>retarded</font> waves are outgoing, <font color='red'>advanced</font> waves are incoming</li>
		  		<li>no particle confinement is needed to reflect outgoing waves into incoming waves</li>
		  		<li><font color='lime'>retarded</font> and <font color='red'>advanced</font> waves leave the oscillator with opposite phases (&Delta; = &pi;)</li>
		  		<li>time-symmetric waves are modeled after the Transactional Interpretation of QM</li>
		  		<li>only the free particle case is depicted -- later versions will include double slit, Compton scattering, etc.</li>
		  		<li>derivation of wave origin times is <span id="derivation_span" style="color:orange">here</span></li>
		  	</ul>
		  	<div style="margin:30px;">
			TI references:<br>
			&nbsp;&nbsp;&nbsp;<a style="color:white" href="https://en.wikipedia.org/wiki/Transactional_interpretation">Wikipedia article about TI</a><br>
		  	&nbsp;&nbsp;&nbsp;<a style="color:white" href="https://faculty.washington.edu/jcramer/TI/">John Cramer's TI website</a><br>
			&nbsp;&nbsp;&nbsp;<a style="color:white" href="https://www.google.com/books/edition/The_Quantum_Handshake/WklECwAAQBAJ"><b>The Quantum Handshake</b></a> book by John Cramer<br>
			&nbsp;&nbsp;&nbsp;<a style="color:white" href="https://www.google.com/books/edition/The_Transactional_Interpretation_of_Quan/3hNkEAAAQBAJ"><b>The Transactional Interpretation of Quantum Mechanics</b></a> book by Ruth Kastner<br>
			&nbsp;&nbsp;&nbsp;plus many other articles, books, and videos by Cramer and Kastner<br>
			<br>
			&nbsp;&nbsp;&nbsp;see also<br>
			&nbsp;&nbsp;&nbsp;<a style="color:white" href="https://www.google.com/books/edition/Collective_Electrodynamics/GkDR4e2lo2MC"><b>Collective Electrodynamics</b></a> book by Carver Mead<br>
			&nbsp;&nbsp;&nbsp;<a style="color:white" href="https://www.google.com/books/edition/Schrodinger_s_Kittens_and_the_Search_for/11ps2p8hIy8C"><b>Schrodinger's Kittens</b></a> book by John Gribbin<br>
			</div>
		</div>

		<div id="derivation" style="font-family:Cambria,Math; background-color:rgb(0,0,0); position:absolute; color:rgb(255,255,255); text-align:center; height:100%; width:100%; padding:0px; border-width:0px; margin:0px; min-width:300px; z-index:2; visibility:hidden;">
      		<button type="button" id="return_from_derivation" style="font-weight:bold">RETURN</button>
      		<iframe src="derivation.pdf" width="100%" height="100%" style="border:none;"></iframe>
    	</div>

		<div id="UI" style="font-family:Arial,Helvetica,sans-serif; visibility:hidden; text-align:center; background-color:rgb(0,0,0); color:rgb(255,255,255); position:absolute; width:100%; left:0%; top:0px">
      		<table style="text-align:center; border-collapse:collapse; margin-left:auto; margin-right:auto">
        		<tr style="height:50px; border-bottom:3px solid blue"> <th style="width:200px;"></th> <th style="border-left:3px solid blue">web browser</th> <th style="border-left:1px solid blue">smart phone or tablet</th> </tr>
        		<tr style="height:50px; border-bottom:1px solid blue"> <td style="text-align:left">show/hide control menu</td> <td style="border-left:3px solid blue; font-style:italic;">left click</td> <td style="border-left:1px solid blue; font-style:italic;">tap</td> </tr>
        		<tr style="height:50px; border-bottom:1px solid blue"> <td style="text-align:left">change value of user-settable fields</td> <td style="border-left:3px solid blue; font-style:italic;">left click</td> <td style="border-left:1px solid blue; font-style:italic;">tap</td> </tr>
        		<tr style="height:50px; border-bottom:1px solid blue"> <td style="text-align:left">reposition inspector crosshairs</td> <td style="border-left:3px solid blue; font-style:italic;">mouse drag</td> <td style="border-left:1px solid blue; font-style:italic;">touch drag</td> </tr>
        		<tr style="height:50px; border-bottom:1px solid blue"> <td style="text-align:left">fine-tune crosshair position</td> <td style="border-left:3px solid blue; font-style:italic;">arrow keys</td> <td style="border-left:1px solid blue; font-style:italic;">N/A</td> </tr>
        		<tr style="height:50px; border-bottom:1px solid blue"> <td style="text-align:left">show description of button or field</td> <td style="border-left:3px solid blue; font-style:italic;">mouse hover</td> <td style="border-left:1px solid blue; font-style:italic;">N/A</td> </tr>
        		<tr style="height:50px; border-bottom:1px solid blue"> <td style="text-align:left">show full precision of field while paused</td> <td style="border-left:3px solid blue; font-style:italic;">mouse hover</td> <td style="border-left:1px solid blue; font-style:italic;">N/A</td> </tr>
      		</table><br>
      		<br>
      		step backward, step forward, and zoom buttons can be held down for continuous stepping or zooming
      		<br><br><br>
      		<button type="button" id="return_from_UI" style="font-weight:bold">RETURN</button>
    	</div>

        <div id="controls" style="background-color:rgba(0,0,0,0); margin-top:auto; margin-bottom:auto; position:absolute; color:rgb(255,255,255); font-family:times; z-index:3; visibility:hidden;">
            <button id="exit_button" title="exit animation" type="button">exit</button>&nbsp;&nbsp;&nbsp;
            <span id="notation" title="show annotation"><input id="notation_checkbox" type="checkbox">notation</span>&nbsp;&nbsp;&nbsp;
            <span id="time_span" title="current time&#013;[Click to change value]" style="padding:0px;">t = <span id="time">0</span></span><br>
            <span title="animation direction in time">time direction:
            <span id="backward_radio" title="animate backward in time"><input id="backward_button" type="radio" name="time_direction"><span>backward</span></span>
            <span id="forward_radio" title="animate forward in time"><input id="forward_button" type="radio" name="time_direction"><span>forward</span></span>
        	</span><br>
            <span id="retarded" title="show forward-in-time waves"><input id="retarded_checkbox" type="checkbox">retarded waves</span>
			<span id="advanced" title="show backward-in-time waves"><input id="advanced_checkbox" type="checkbox">advanced waves</span><br>
            <button id="faster_button" type="button" title="increase animation rate x2">faster</button>
            <button id="slower_button" type="button" title="decrease animation rate x2">slower</button>
            <button id="pause_resume_button" type="button" title="pause/resume animation">pause </button>
			<button id="reset_button" type="button" title="reset animation">reset</button><br>
            <span id="single_steps" title="step animation backward/forward while paused">single step:
            <button id="stepbackward_button" type="button" title="step animation backward in time">backward</button>
            <button id="stepforward_button" type="button" title="step animation forward in time">forward</button>
        	</span>
		
	        <div id="dblslit_controls" style="background-color:rgba(0,0,0,0); margin-top:auto; margin-bottom:auto; position:absolute; color:rgb(255,255,255); font-family:times; z-index:3; visibility:hidden;">
				open slits:
				<input id="left_slit_checkbox" type="checkbox">left slit
				<input id="right_slit_checkbox" type="checkbox">right slit<br>
	            show:<br>
	            <input id="overlap_checkbox" type="checkbox">overlap only<br>
	            <input id="pattern_checkbox" type="checkbox">interference pattern<br>
				<input id="source_waves_checkbox" type="checkbox">source waves
				<input id="destination_waves_checkbox" type="checkbox">destination waves<br>
	            </span><br>
	            <span id="set_srcdest">
	            <button id="source_button" type="button">set source</button>
	            <button id="destination_button" type="button">set destination</button><br>
	            </span>
	           	<span id="dblslit_inspector" title="wave details [drag crosshairs to any wave location"><input id="inspector_checkbox" type="checkbox">inspector</span><br>
	        </div>
        
	        <div id="freeparticle_controls" style="background-color:rgba(0,0,0,0); margin-top:auto; margin-bottom:auto; position:absolute; color:rgb(255,255,255); font-family:times; z-index:3; visibility:hidden;">
	        	<!-- wave amplitude:
	        	<input id="complex_button" type="radio" name="wave_type">complex
	        	<input id="real_button"    type="radio" name="wave_type">real<br>
	        	<br> -->
	          	<span title="particle location">particle: 
		          	<span title="x coordinate of particle">x = <span id="x_particle">0</span></span>&nbsp;&nbsp;
		          	<span title="y coordinate of particle">y = <span id="y_particle">0</span></span></span><br>
	        	<span title="Particle Speed v&#013;(0 <= v < c)" id="SpeedSlider">
	          		<span style="font-family:cambria_math">speed (v): 0</span>
		          	<input id="speed_range" type="range" min="0" max="1000" value="0" class="slider"
		          	style="background:rgb(126,126,126); width:150px; height:10px; vertical-align:middle">
		          	<span style="font-family:cambria_math">c</span>
	      		</span><br>
	          	<span id="v_over_c_span" title="group velocity as fraction of c (0 <= v/c < 1)&#013;[Click to change value]">v/c = <span id="v_over_c">0</span></span>
	          	&nbsp;&nbsp;
<!-- 	          	<span id="v_span" title="group velocity (0 <= v < c)&#013;[Click to change value]">v = <span id="v">0</span> m/s</span>
	        	<br> -->
	        	<span id="u_over_c_span" title="phase velocity as fraction of c&#013;[Click to change value]">u/c = <span id="u_over_c"></span></span>
	          	&nbsp;&nbsp;
<!-- 	          	<span id="u_span" title="phase velocity (1 < u < &infin;)&#013;[Click to change value]">u = <span id="u">Infinity</span> m/s</span>
	        	<br> -->
	        	<span id="gamma_span" title="Lorentz factor: ratio for length contraction and time dilation&#013;[Click to change value]" style="padding:0px; font-family:times">
	          		<span style="font-family:cambria_math">&gamma; = </span><span id="gamma">1</span>
	          	</span><br>
	          	<span title="Change Animation Scale">zoom:</span>
        		<button title="Zoom Out" id="zoom_out_button" style="font-weight:bold; text-align:center; padding:0px; width:30px;">-</button>
        		<button title="Undo Zooming" id="zoom_zero_button" style="font-weight:bold; text-align:center; padding:0px; width:30px;">0</button>
        		<button title="Zoom In" id="zoom_in_button" style="font-weight:bold; text-align:center; padding:0px; width:30px;">+</button><br>
	          	<span title="wave details [drag crosshairs to a wave or particle location]">inspect: </span>
		        <span id="point_inspector" title="inspect a point"><input id="point_inspector_checkbox" type="checkbox">point</span>
		        <span id="particle_inspector" title="inspect the particle"><input id="particle_inspector_checkbox" type="checkbox">particle</span><br>
	          	<span id="inspector" style="background-color:rgba(0,0,0,0); margin-top:auto; margin-bottom:auto; position:absolute; color:rgb(255,255,255); font-family:times; z-index:3; visibility:hidden;">
	          		<span id="stationary_radio" title="inspection point stays stationary"><input id="stationary_button" type="radio" name="inspector_motion">stationary</span><br>
            		<span id="particle_radio" title="inspection point moves with particle at group velocity v"><input id="group_button" type="radio" name="inspector_motion">move at group velocity</span><br>
            		<span id="de_Broglie_radio" title="inspection point moves with de Broglie wave at phase velocity c&sup2;/v">
            			<input id="phase_button" type="radio" name="inspector_motion">move at phase velocity</span><br>
            		<span title="location of inspection point">inspect:
			        	<span title="x coordinate of inspection point">x = <span id="x_inspect">0</span></span>&nbsp;&nbsp;
			        	<span title="y coordinate of inspection point">y = <span id="y_inspect">0</span></span></span><br>
	        		<span id="point_inspection">
		        		<span>dx = <span id="dx">0</span></span>&nbsp;&nbsp;&nbsp;
		        		<span>dy = <span id="dy">0</span></span><br>
		        		<span title="sum of real amplitudes of retarded and advanced waves">amplitude sum = <span id="real">0</span></span><br>
		        		<table id='point_table'>
		        			<tr title="waves arriving at inspection point from both time directions"><td>wave</td>
		        				<td title="forward-in-time wave" style="color:lime">retarded</td>
		        				<td title="backward-in-time wave" style="color:red">advanced</td></tr>
		        			<tr title="distances from wave origins to inspection point"><td>r origin</td>
		        				<td id="r1">0</td>
		        				<td id="r2">0</td></tr>       				
		        			<tr title="x location of wave origins"><td>x origin</td>
		        				<td id="x1">0</td>
		        				<td id="x2">0</td></tr>
		        			<tr title="delta times"><td>dt</td>
		        				<td id="dt1">0</td>
		        				<td id="dt2">0</td></tr>
		        			<tr title="time waves leave origins"><td>t origin</td>
		        				<td id="t1">0</td>
		        				<td id="t2">0</td></tr>
		        			<tr title="cycles of waves"><td>cycle</td>
		        				<td id="cycle1">0</td>
		        				<td id="cycle2">0</td></tr>
		        			<tr title="phases of waves"><td>phase</td>
		        				<td id="phase1">0</td>
		        				<td id="phase2">0</td></tr>
		        			<tr title="real amplitudes of waves"><td>amplitude</td>
		        				<td id="real1">0</td>
		        				<td id="real2">0</td></tr>
		        		</table>
	        		</span>
	        		<span id="particle_inspection">
	        			<span id="particle_time" title="time particle is at this location">t = <span id="t_part">0</span></span><br>
		        		<table id='particle_table'>
		        			<tr title="waves leaving particle in both time directions"><td>wave</td>
		        				<td title="forward-in-time wave" style="color:lime">retarded</td>
		        				<td title="backward-in-time wave" style="color:red">advanced</td></tr>     				
		        			<tr title="cycles of waves"><td>cycle</td>
		        				<td id="cycle1_part">0</td>
		        				<td id="cycle2_part">0</td></tr>
		        			<tr title="phases of waves"><td>phase</td>
		        				<td id="phase1_part">0</td>
		        				<td id="phase2_part">0</td></tr>
		        			<tr title="real amplitudes of waves"><td>amplitude</td>
		        				<td id="real1_part">0</td>
		        				<td id="real2_part">0</td></tr>
		        		</table>
	        		</span>
        		</span>

	        </div>

        </div>

    </body>
		
		<script type="text/javascript">
		
/*
 * http://jmvidal.cse.sc.edu/talks/javascript/complexnumbersexample.html
 *
 * Complex.js:
 * This file defines a Complex class to represent complex numbers.
 * Recall that a complex number is the sum of a real number and an
 * imaginary number and that the imaginary number i is the
 * square root of -1.
 */

/*
 * The first step in defining a class is defining the constructor
 * function of the class. This constructor should initialize any
 * instance properties of the object. These are the essential
 * "state variables" that make each instance of the class different.
 */
function Complex(real, imaginary) {
    this.Re = real;       // real part of the number
    this.Im = imaginary;  // imaginary part of the number
}

/*
 * The second step in defining a class is defining its instance
 * methods (and possibly other properties) in the prototype object
 * of the constructor. Any properties defined in this object will
 * be inherited by all instances of the class. Note that instance
 * methods operate implicitly on the 'this' keyword. For many methods,
 * no other arguments are needed.
 */

Complex.prototype.toPhasor = function () { return new Phasor(Math.sqrt(this.Re*this.Re + this.Im*this.Im,Math.atan(this.Im/this.Re))); };

// Return the modulus of this complex number. This is defined as
// its distance from the origin (0,0) of the complex plane.
Complex.prototype.modulus = function() { return Math.sqrt(this.Re*this.Re + this.Im*this.Im); };

// Return the phase (aka complex argument) of this complex number. This is defined as
// the counterclockwise angle from the positive real axis
Complex.prototype.phase = function() { return Math.atan(this.Im/this.Re); };  // returned angle is in radians

// Return a complex number that is the negative of this one.
Complex.prototype.negative = function() { return new Complex(-this.Re, -this.Im); };

// Return a complex number that is the conjugate of this one.
Complex.prototype.conjugate = function() { return new Complex(this.Re, -this.Im); };

// Add a complex number to this one and return the sum in a new object.
Complex.prototype.add = function(that) { return new Complex(this.Re + that.Re, this.Im + that.Im); };

// Multiply this complex number by another and return the product as a
// new Complex object.
Complex.prototype.multiply = function(that) { return new Complex(this.Re * that.Re - this.Im * that.Im, this.Re * that.Im + this.Im * that.Re); };

// Convert this complex number to a string in a useful way.
// This is invoked when a Complex object is used as a string.
Complex.prototype.toString = function() { return "(" + this.Re + ",i*" + this.Im + ")"; };

// Return the real portion of this complex number. This function
// is invoked when a Complex object is treated as a primitive value.
Complex.prototype.PhasorOf = function() { return this.Re; };

// Test whether this complex number has the same value as another.
Complex.prototype.equals = function(that) { return this.Re == that.Re && this.Im == that.Im; };

// Return the real portion of this complex number
Complex.prototype.real = function() { return this.Re; };

// Return the imaginary portion of this complex number
Complex.prototype.imaginary = function() { return this.Im; };

/*
 * The third step in defining a class is to define class methods,
 * constants, and any needed class properties as properties of the
 * constructor function itself (instead of as properties of the
 * prototype object of the constructor). Note that class methods
 * do not use the 'this' keyword: they operate only on their arguments.
 */

// Add two complex numbers and return the result.
// Contrast this with the instance method add()
Complex.sum = function (z1, z2) { return new Complex(z1.Re + z2.Re, z1.Im + z2.Im); };

// Multiply two complex numbers and return the product.
// Contrast with the instance method multiply()
Complex.product = function(z1, z2) { return new Complex(z1.Re * z2.Re - z1.Im * z2.Im, z1.Re * z2.Im + z1.Im * z2.Re); };

// Return the modulus (aka modulus) of a complex number. This is defined as
// its distance from the origin (0,0) of the complex plane.
Complex.modulus = function(z) { return Math.sqrt(z.Re*z.Re + z.Im*z.Im); };

// Return the phase (aka complex argument) of a complex number. This is defined as
// the counterclockwise angle from the positive real axis
Complex.phase = function(z) { return Math.atan(z.Im/z.Re); };  // returned angle is in radians

// Return a complex number that is the negative of this one.
Complex.negative = function(z) { return new Complex(-z.Re, -z.Im); };

// Return the complex conjugate of a complex number
Complex.conjugate = function(z) { return new Complex(z.Re, -z.Im); };

// Test whether two complex numbers have the same value.
Complex.equal = function(z1,z2) { return z1.Re == z2.Re && z1.Im == z2.Im; };

// Return the real portion of a complex number
Complex.real = function(z) { return z.Re; };

// Return the imaginary portion of a complex number
Complex.imaginary = function(z) { return z.Im; };

// Here are some useful predefined complex numbers.
// They are defined as class properties, and their names are in uppercase
// to indicate that they are intended to be constants (although it is not
// possible to make JavaScript properties read-only).
Complex.ZERO = new Complex(0,0);
Complex.ONE = new Complex(1,0);
Complex.I = new Complex(0,1);

function waveSum(Re, Im, n)
{
	this.Re = Re;
	this.Im = Im;
	this.n = n; // number of waves at location
}

function Phasor(modulus, phase) {
    this.modulus = modulus;       // The modulus of the complex number
    this.phase = phase;  // The complex argument
}

Phasor.prototype.toString = function() { return "phase = " + (this.phase % (2*Math.PI)).toPrecision(5) + "   modulus = " + (this.modulus).toPrecision(5); };

Phasor.prototype.Re = function() {return this.modulus*Math.cos(this.phase); };

Phasor.prototype.Im = function() {return this.modulus*Math.sin(this.phase); };
 
Phasor.prototype.toComplex = function () {return new Complex(this.Re, this.Im); };

Phasor.prototype.from_ReIm = function(Re, Im)
{
	this.modulus = Math.sqrt(Re*Re + Im*Im);
	if (Re == 0)
	{
		if (Im == 0) 	{this.phase = 0;}
		else if (Im > 0){this.phase = Math.PI/2;}
		else 			{this.phase = 3*Math.PI/2;}
	}
	else if (Re > 0)
	{
		if (Im >= 0) 	{this.phase = Math.atan(Im/Re);}
		else 			{this.phase = 2*Math.PI - Math.atan(-Im/Re);}
	}
	else
	{
		if (Im >= 0) 	{this.phase = Math.PI - Math.atan(Im/(-Re));}
		else			{this.phase = Math.PI + Math.atan(Im/Re);}
	}
};

Phasor.fromComplex = function(z) {return new Phasor(distance(0, 0, z.Re, z.Im), Math.atan(z.Im/z.Re)); };

Phasor.from_ReIm = function(Re, Im)
{
	var modulus = Math.sqrt(Re*Re + Im*Im);
	if (Re == 0)
	{
		if (Im == 0) 	{return null_phasor;}
		else if (Im > 0) {return new Phasor(modulus, Math.PI/2);}
		else 			{return new Phasor(modulus, 3*Math.PI/2);}
	}
	else if (Re > 0)
	{
		if (Im >= 0) 	{return new Phasor(modulus, Math.atan(Im/Re));}
		else 			{return new Phasor(modulus, 2*Math.PI - Math.atan(-Im/Re));}
	}
	else
	{
		if (Im >= 0) 	{return new Phasor(modulus, Math.PI - Math.atan(Im/(-Re)));}
		else			{return new Phasor(modulus, Math.PI + Math.atan(Im/Re));}
	}
};

Phasor.sum = function(p1, p2) {
	var x1 = p1.modulus*Math.cos(p1.phase);
	var y1 = p1.modulus*Math.sin(p1.phase);
	var x2 = p2.modulus*Math.cos(p2.phase);
	var y2 = p2.modulus*Math.sin(p2.phase);
	return Phasor.from_ReIm(x1 + x2, y1 + y2);
};

var null_phasor = new Phasor(0, 0);

// Wave from a point source
function Wave(id, retarded, src_side, t0, x0, y0, modulus0, phase0)
{
    this.id = id;
    this.retarded = retarded;   // true:retarded  false:advanced
    this.src_side = src_side; 	// wave is on same side as source
	this.t0 = t0;       		// time when wave train originates from its origin
    this.x0 = x0;       		// x location of wave origin
    this.y0 = y0;       		// y location of wave origin (y0 == half_h means at slits)
	this.modulus0 = modulus0;   // modulus of wave at origin at t0
	this.phase0 = phase0;       // phase of wave at origin at t0 [radians]
}

Wave.prototype.toString = function()
{
    var type;
    
    if (this.retarded) {type = "Retarded Wave";} else {type = "Advanced Wave";}
    return  type + "   " + this.id + "   t0 = " +
            this.t0 + "   x0,y0 = " + this.x0 + "," + this.y0 +
			"   modulus0,phase0 = " + this.modulus0 + "," + this.phase0 % (2*Math.PI) +
			"   frequency = " + frequency + "   coherence_time =  " + coherence_time;
};

Wave.prototype.onLightCone = function(d)
{
    if (this.retarded) 	{return ((t >= this.t0) && (d >= t - this.t0 - coherence_time) && (d <= t - this.t0));}
    else 				{return ((t <= this.t0) && (d >= this.t0 - coherence_time - t) && (d <= this.t0 - t));}
};

Wave.prototype.phasor = function(d)
{
	var modulus, phase;
	
    if (this.retarded)
    {
        phase = this.phase0 + 2*Math.PI*frequency*(t - this.t0 - d);
    }
    else
    {
        phase = this.phase0 + 2*Math.PI*frequency*(t - this.t0 + d);
        if (this.y0 != half_h)	phase = Math.PI + phase; // wave not centered on slit
    }
	phase = phase % (2*Math.PI);
	if (phase < 0) phase = 2*Math.PI + phase;
    modulus = this.modulus0; // undiminished by distance
	//modulus = (1-d/h_full)*this.modulus0; // diminish wave modulus with increasing radius, down to zero at full height of window
	//alert("forwardLightCone t,d = " + t + " , " + d + "   modulus, phase = " + modulus + " , " + phase);
	return new Phasor(modulus, phase);
};

Wave.prototype.toComplex = function(d) {return(this.phasor(d).toComplex());};

Wave.prototype.hasValue = function(x, y)
{
    if ((this.retarded && !ret_waves) || (!this.retarded && !adv_waves)) return false;
	if (this.y0 == half_h) // wave centered on slit
	{
		if (this.src_side && y < half_h) return false;
		if (!this.src_side &&  y > half_h) return false;
	}
	else // wave not centered on slit
	{
		if (this.src_side && y < half_h) return false;
		if (!this.src_side && y > half_h) return false;
	}
	//alert("t = " + t + "   x = " + x + "   y = " + y);
	//alert(this.onLightCone(distance(this.x0, this.y0, x, y)));
	return this.onLightCone(distance(this.x0, this.y0, x, y));
};

Wave.prototype.value = function(x, y) {return this.phasor(distance(this.x0,this.y0,x,y));};

// radius calculations
Wave.prototype.innerRadius = function()
{
    if (this.retarded)
        if (t > this.t0 + coherence_time) {return (t - this.t0 - coherence_time);}
        else {return 0; }
    else
        if (t < this.t0 + coherence_time) {return (this.t0 + coherence_time - t);}
        else {return 0;}
};

Wave.sum = function (wave1, wave2) {return Complex.sum(wave1.toComplex, wave2.toComplex);};
		
function $i(id) { return document.getElementById(id); }
//function $r(parent,child) { (document.getElementById(parent)).removeChild(document.getElementById(child)); }
//function $t(name) { return document.getElementsByTagName(name); }
//function $c(code) { return String.fromCharCode(code); }
//function $h(value) { return ('0'+Math.max(0,Math.min(255,Math.round(value))).toString(16)).slice(-2); }
//function _i(id,value) { $t('div')[id].innerHTML+=value; }
//function _h(value) { return !hires?value:Math.round(value/2); }

//function Angle() {this.radians;}

function Point2D(x, y) {this.x = x; this.y = y;}
Point2D.prototype.toString = function() { return "x = " + this.x + "   y = " + this.y; };
Point2D.distance = function(P1, P2) {return distance(P1.x, P1.y, P2.x, P2.y); };

var frame_timerID;  //interval timer ID
var started=false;
var inspector, point_inspector, particle_inspector, ret_waves, adv_waves, src_waves, dest_waves, left_slit, right_slit, paused, overlap_only, notation;  // checkbox toggles
var inspector_motion; // 'stationary' or 'particle' or 'de Broglie'
var inspector_current_time = false;
var delta_t;
var t;
var v,u,c,gamma;
const c_value = 299792458; // [m/s]
 
// free particle variables
var mode; //'dblslit' or 'free'
var centered = false;;
var x_particle_start, x_particle, y_particle;
var	X_delta = 100; // can be adjusted
var Y_delta = 100; // can be adjusted
var offset_x = 0;
var offset_y = 0;
var x,y,dx,dy,dt_1,dt_2,t1,t2,x1,y1,x2,y2,r1,r2;
var cycle1,cycle2,phase1,phase2,real1,real2,real;
var t_particle;

// double slit variables
var d_slits;   // distance between slits
var w_slit;    // width of each slit
var w_barrier; // thickness of screen
var retsrc = Wave();	// retarded wave from source (src side)
var retleft = Wave();	// retarded wave from left slit (dest side)
var retright = Wave();	// retarded wave from right slit (dest side)
var retdest = Wave();   // retarded wave from destination (dest side)
var advsrc = Wave();    // advanced wave from source (src side)
var advleft = Wave(); 	// advanced wave from left slit (src side)
var advright = Wave(); 	// advanced wave from right slit (src side)
var advdest = Wave();  	// advanced wave from destination (dest side)
var x_src, y_src, x_dest, y_dest;
var dx_src, dy_src, dx_dest, dy_dest;
var x_left, y_left, d_left;
var x_right, y_right, d_right;
var t_retsrc, t_retleft, t_retright, t_retdest,t_adv_src, t_advleft, t_advright, t_advdest;
var red, green, blue;
var p_result = new Phasor();
var x0_inspector, t0_inspector; // space coord. of inspector point when set at time t0_inspector
var x_inspector, y_inspector;  // space coord. of inspector point
var X_inspector, Y_inspector;  // screen coord. of inspector point
var dX_inspector, dY_inspector;
var r_inspector;
var coherence_time, min_coherence_time, frequency;
var sum = new waveSum();
var half_w, half_h;
var Lsrc_Float64, Lleft_Float64, Lright_Float64, Uleft_Float64, Uright_Float64, Udest_Float64;

var P_mousedown = new Point2D();
var P_mouseup = new Point2D();
var prev_P_mouseup = new Point2D();

var w_full, h_full;  //full width,height of client window and drawing frame
var w = 0;
var h = 0;
var annotation_font="16pt cambria_math";
//var annotation_color='white';

var dragging_inspector = false;
var setting_source = false;
var setting_destination = false;
var rotation; //degrees
var gesture=false;
var scale;
var prev_scale;
var theta;  //rotation in radians
var prev_theta;  //previous rotation in radians
var canvas_x = 0; //x location of canvas origin
var canvas_y = 0; //y location of canvas origin
var annotation_font="16pt cambria_math";
var annotation_color='white';

var controls;
var dblslit_controls;
var freeparticle_controls;
var canvas;
var context;
var imageData, image_data, image_buffer, image_buffer_8, image_buffer_32;
var upper_buffer, upper_buffer_8, upper_buffer_32;
var lower_buffer, lower_buffer_8, lower_buffer_32;
var blank_buffer, blank_buffer_8;

var fps = 24;
var msec_delay;

function isEven(num) {return num % 2 == 0;}
function isOdd(num) {return Math.abs(num % 2) == 1;}
function inherit(id) {$i(id).style.visibility = 'inherit';}
function hidden(id) {$i(id).style.visibility = 'hidden';}
function On(id) {return ($i(id).checked && !$i(id).disabled);}

function show_table_column(table_id, col_no, do_show)
{
    var rows = document.getElementById(table_id).rows;
    
    for (var row = 0; row < rows.length; row++) 
    {
        var cols = rows[row].cells;
        if (col_no >= 0 && col_no < cols.length) {cols[col_no].style.display = do_show ? '' : 'none';}
    }
}

function fillArc(x,y,r,start,end,color)
{
	// start: 0 radians is at 3 o'clock
	// end: Math.PI radians is at 9 o'clock (half circle)

	context.beginPath();
	context.arc(x,y,r,start,end,true); // draw the arc counterclockwise
	context.closePath(); // close the path to form a pie slice
	context.fillStyle = color; // set fill color
	context.fill(); // fill the arc
}

function fillCircle(x,y,r,color) {fillArc(x,y,r,0,2*Math.PI,color);}

function show_speed()
{
	var v_value,u_value;

	set('v_over_c',v.toPrecision(3));
	v_value = v*c_value;
	//set('v',v_value.toFixed());
	set('u_over_c',u.toPrecision(3));
	u_value = u*c_value;
	//set('u',u_value.toFixed());
	set('gamma',gamma.toPrecision(3));
	document.querySelector('#speed_range').value = v*1000;
}

function x_to_X(x) // x to screen location X
{
  if (centered) return Math.floor((x*scale - half_w));
  else          return Math.floor(((x - offset_x)*scale + half_w));
}

function X_to_x(X) // X screen location to x
{
  if (centered) return ((X - half_w)/scale);
  else          return ((X - half_w)/scale + offset_x);
}

function y_to_Y(y) // y to screen location Y
{
  if (centered) return Math.floor((half_h - y*scale));
  else          return Math.floor((half_h - (y - offset_y)*scale));
}

function Y_to_y(Y) // Y screen location to y
{
  if (centered) return (-(Y - half_h)/scale);
  else          return (-(Y - half_h)/scale + offset_y);
}

function get_t()
{
  var badinput,user_input,time;
  
  badinput = true;
  do
  {
    user_input = prompt("Enter time",get('time'));
    if (user_input == null) return(false); // user has canceled
    else // user has entered something
    {
      if (isNaN(Number(user_input))) alert(user_input + " is not a number"); // not a number
      else // is a number
      {
        time = Number(user_input); t = time;
        set('time',t.toPrecision(5));
        badinput = false;
      }
    }
  }
  while(badinput);
  return(true);
}

function get_v_over_c()
{
  var badinput,user_input,v_over_c;
  
  badinput = true;
  do
  {
    user_input = prompt("Enter group velocity divided by the speed of light",v);
    if (user_input == null) return(false); // user has canceled
    else // user has entered something
    {
      if (isNaN(Number(user_input))) alert(user_input + " is not a number"); // not a number
      else // is a number
      {
        v_over_c = Number(user_input);
        if (v_over_c >= 1 || v_over_c < 0) alert("v/c must be between 0 and 1");
        else // OK to use
        {
          v = v_over_c;
          if (v == 0) {u = Infinity;} else {u = c*c/v;}
          gamma = 1/Math.sqrt(1-(v*v)/(c*c)); 
          show_speed();
          badinput = false;
        }
      }
    }
  }
  while(badinput);
  return(true);
}

/*function get_v()
{
  var badinput,user_input,v_value;
  
  badinput = true;
  do
  {
    user_input = prompt("Enter group velocity [m/s]",v*c_value);
    if (user_input == null) return(false); // user has canceled
    else // user has entered something
    {
      if (isNaN(Number(user_input))) alert(user_input + " is not a number"); // not a number
      else // is a number
      {
        v_value = Number(user_input);
        if (v_value < 0 || v_value > c_value) alert("v must be between 0 and " + c_value);
        else // OK to use
        {
          v = v_value/c_value;
          if (v == 0) {u = Infinity;} else {u = c*c/v;}
          gamma = 1/Math.sqrt(1-(v*v)/(c*c)); 
          show_speed();
          badinput = false;
        }
      }
    }
  }
  while(badinput);
  return(true);
}*/

function get_u_over_c()
{
  var badinput,user_input,u_over_c;
  
  badinput = true;
  do
  {
    user_input = prompt("Enter phase velocity divided by c (> 1)",u);
    if (user_input == null) return(false); // user has canceled
    else // user has entered something
    {
      if (isNaN(Number(user_input))) alert(user_input + " is not a number"); // not a number
      else // is a number
      {
        u_over_c = Number(user_input);
        if (u_over_c <= 1) alert("u/c must be greater than 1");
        else // OK to use
        {
          u = u_over_c; v = c*c/u;
          gamma = 1/Math.sqrt(1-(v*v)/(c*c)); 
          show_speed();
          badinput = false;
        }
      }
    }
  }
  while(badinput);
  return(true);
}

/*function get_u()
{
  var badinput,user_input,u_value;
  
  badinput = true;
  do
  {
    user_input = prompt("Enter phase velocity [m/s] (> c)",u*c_value);
    if (user_input == null) return(false); // user has canceled
    else // user has entered something
    {
      if (isNaN(Number(user_input))) alert(user_input + " is not a number"); // not a number
      else // is a number
      {
        u_value = Number(user_input);
        if (u_value <= c_value) alert("u must be greater than c");
        else // OK to use
        {
          u = u_value/c_value; v = c*c/u;
          gamma = 1/Math.sqrt(1-(v*v)/(c*c)); 
          show_speed();
          badinput = false;
        }
      }
    }
  }
  while(badinput);
  return(true);
}*/

function get_gamma()
{
  var badinput,user_input,gamma_value;

  badinput = true;
  do
  {
    user_input = prompt("Enter gamma (Lorentz factor >=1)",gamma);
    if (user_input == null) return(false); // user has canceled
    else // user has entered something
    {
      if (isNaN(Number(user_input))) alert(user_input + " is not a number");
      else // is a number
      {
        gamma_value = Number(user_input);
        if (gamma_value < 1) alert("gamma must be greater than or equal to 1");
        else
        {
          gamma = gamma_value;
          v = Math.sqrt(1-(1/gamma)*(1/gamma));
          if (v == 0) {u = Infinity;} else {u = c*c/v;}
          show_speed();
          badinput = false;
        }
      }
    }
  }
  while(badinput);
  return(true);
}

function speed_change()
{
  var v_over_c;
  
  v_over_c = $i('speed_range').value/1000;
  if (v_over_c == 1) {v_over_c = 0.999; $i('speed_range').value = v_over_c*100;}
  v = v_over_c; gamma = 1/Math.sqrt(1-(v*v)/(c*c));
  if (v == 0) {u = Infinity;} else {u = c*c/v;}
  show_speed();
  drawFrame();
}

function timeSpan()		{if (get_t()) 		drawFrame();}
function t1Span()		{t = t1; drawFrame();}
function t2Span()		{t = t2; drawFrame();}
function particle_timeSpan() {inspector_current_time = true; drawFrame();}
function gammaSpan()  	{if (get_gamma())	reset();}
function v_over_cSpan()	{if (get_v_over_c())reset();}
function vSpan()  		{if (get_v()) 		reset();}
function u_over_cSpan() {if (get_u_over_c())reset();}
function uSpan()  		{if (get_u()) 		reset();}
function omegaSpan()	{if (get_omega())	drawFrame();}
function freqSpan()		{if (get_freq())	drawFrame();}
function periodSpan()	{if (get_period())	drawFrame();}
function particleSpan()	{if (get_particle())drawFrame();}
function massSpan()		{if (get_mass())	drawFrame();}
function MeVSpan()		{if (get_MeV())		drawFrame();}

function overlapDblSlit(x,y)
{
    var n;
    
    n = 0;
    if (retsrc.hasValue(x,y)) n++;
    if (retleft.hasValue(x,y)) n++;
    if (retright.hasValue(x,y)) n++;
    if (retdest.hasValue(x,y)) n++;
    if (advsrc.hasValue(x,y)) n++;
    if (advleft.hasValue(x,y)) n++;
    if (advright.hasValue(x,y)) n++;
    if (advdest.hasValue(x,y)) n++;
    return (n > 1);
}

function overlapFree()
{
	return ((Math.abs(x_to_X(x_particle) - x_to_X(x_inspector)) <= X_delta) &&
	 (Math.abs(y_to_Y(y_particle) - y_to_Y(y_inspector)) <= Y_delta));
}

function get(name) {return($i(name).innerHTML);}
function set(name,value) {$i(name).innerHTML = value;}

function drawLine(x1,y1,x2,y2,width,color)
{
	context.save();
	context.strokeStyle = color;
	context.lineWidth = width;
	context.beginPath();
	context.moveTo(x1,y1);
	context.lineTo(x2,y2);
	context.stroke();
	context.restore();
}

function drawText(text,x,y,align,base,angle)
{
  context.save();
  context.fillStyle = annotation_color;
  context.font = annotation_font;
  context.textAlign = align;
  context.textBaseline = base;
  context.translate(x,y);
  context.rotate(angle);
  context.fillText(text,0,0);
  context.restore();
}

function drawFreeInspector()
{
	var Y;

	context.save();

	if ((v == 0 || inspector_current_time) && particle_inspector) {x_inspector = x_particle; y_inspector = y_particle; X_inspector = x_to_X(x_inspector); Y_inspector = y_to_Y(x_inspector);}
	if 		(point_inspector) 		{Y = y_to_Y(y_inspector); inherit('inspector');}
	else if (particle_inspector) 	{Y = y_to_Y(0); Y_inspector = Y; y_inspector = 0; inherit('inspector');}
	else 							{hidden('inspector'); return;}
	X_inspector = x_to_X(x_inspector);
	if 		(inspector_motion == 'stationary'  || v==0) {context.translate(X_inspector, Y);}
	else if (inspector_motion == 'particle') 			{if (!inspector_current_time) {x_inspector = x0_inspector + v*(t - t0_inspector); X_inspector = x_to_X(x_inspector);}; context.translate(X_inspector, Y);}
	else if (inspector_motion == 'de Broglie' && v!=0) 	{x_inspector = x0_inspector + (t - t0_inspector)/v; context.translate(X_inspector, Y);}
	else return;

/*	context.beginPath();
	context.arc(0, 0, r_inspector, 0, 2*Math.PI, false);
	context.clip();
	context.fillStyle = 'rgba(255,255,255,0.20)';
	context.fill();*/
	drawLine(-r_inspector,0,r_inspector,0,1,'white');
	drawLine(0,-r_inspector,0,r_inspector,1,'white');
	context.restore();

	context.save();
	context.font = "times"
	context.fillStyle = 'white';
	context.textAlign = 'left';
	context.textBaseline = 'top';
	x = x_inspector; y = y_inspector;
    if (point_inspector && overlapFree())
    {	
    	if (ret_waves) {show_table_column('point_table',1,true);} else {show_table_column('point_table',1,false);}
    	if (adv_waves) {show_table_column('point_table',2,true);} else {show_table_column('point_table',2,false);}
    	$i('particle_inspection').style.display = "none"; $i('point_inspection').style.display = "inline";
    	hidden('particle_inspection'); inherit('point_inspection');
    	dx = x - x_particle; dy = y - y_particle;
    	dt_1 = dt1(v,dx,dy); dt_2 = dt2(v,dx,dy);
    	x1 = x_particle - v*dt_1; y1 = 0; // position of particle at event 1
		x2 = x_particle + v*dt_2; y2 = 0; // position of particle at event 2
		t1 = t - dt_1; // stationary time retarded wave left moving particle
		t2 = t + dt_2; // stationary time advanced wave will leave moving particle
		r1 = Math.sqrt((x-x1)*(x-x1) + dy*dy); // distance from retarded origin to inspector point
		r2 = Math.sqrt((x-x2)*(x-x2) + dy*dy); // distance from advanced origin to inspector point
		cycle1 = Math.floor(omega*(t1/gamma)/(2*Math.PI)); // adjusted to moving particle's slower clock
		cycle2 = Math.floor((omega*(t2/gamma) + Math.PI)/(2*Math.PI)); // adjusted to moving particle's slower clock
		phase1 = omega*(t1/gamma) % (2*Math.PI); // adjusted to moving particle's slower clock
		phase2 = (omega*(t2/gamma) + Math.PI) % (2*Math.PI); // adjusted to moving particle's slower clock
		real1 = Math.sin(phase1)/2; real2 = Math.sin(phase2)/2; // normalized to real values between -1 and 1
		real = real1 + real2;

		if (ret_waves) drawLine(x_to_X(x1),y_to_Y(y1),x_to_X(x_inspector), y_to_Y(y_inspector),3,'lime');
		if (adv_waves) drawLine(x_to_X(x2),y_to_Y(y2),x_to_X(x_inspector), y_to_Y(y_inspector),3,'red');

		set('dx',dx.toPrecision(3)); 		set('dy',dy.toPrecision(3));
		set('x_inspect',x.toPrecision(5)); 	set('y_inspect',y.toPrecision(5));
		set('dt1',dt_1.toPrecision(3)); 	set('dt2',dt_2.toPrecision(3));
		set('t1',t1.toPrecision(5)); 		set('t2',t2.toPrecision(5));
		set('x1',x1.toPrecision(4)); 		set('x2',x2.toPrecision(4));
		set('r1',r1.toPrecision(4)); 		set('r2',r2.toPrecision(4));
		set('cycle1',cycle1.toFixed()); 	set('cycle2',cycle2.toFixed());
		set('phase1',phase1.toPrecision(3));set('phase2',phase2.toPrecision(3));
		set('real1',real1.toPrecision(3)); 	set('real2',real2.toPrecision(3));
		set('real',real.toPrecision(3));
    }
    else if (particle_inspector)
    {	
    	if (ret_waves) {show_table_column('particle_table',1,true);} else {show_table_column('particle_table',1,false);}
    	if (adv_waves) {show_table_column('particle_table',2,true);} else {show_table_column('particle_table',2,false);}
    	if (v == 0 || inspector_current_time) {t_particle = t; inspector_current_time = false;}
    	else {t_particle = t - (x_particle - x_inspector)/v;}
    	if (t_particle < t) 		{$i('particle_time').title = "time particle was at this location\n[Click to set to current time]";}
    	else if (t_particle > t)	{$i('particle_time').title = "time particle will be at this location\n[Click to set to current time]";}
    	else                        {$i('particle_time').title = "time particle is at this location";}
    	$i('point_inspection').style.display = "none"; $i('particle_inspection').style.display = "inline";
    	hidden('point_inspection'); inherit('particle_inspection');

    	cycle1 = Math.floor(omega*(t_particle/gamma)/(2*Math.PI)); // adjusted to moving particle's slower clock
		cycle2 = Math.floor((omega*(t_particle/gamma) + Math.PI)/(2*Math.PI)); // adjusted to moving particle's slower clock
		phase1 = omega*(t_particle/gamma) % (2*Math.PI); // adjusted to moving particle's slower clock
		phase2 = (omega*(t_particle/gamma) + Math.PI) % (2*Math.PI); // adjusted to moving particle's slower clock
		real1 = Math.sin(phase1)/2; real2 = Math.sin(phase2)/2; // normalized to real values between -1 and 1

		set('t_part',t_particle.toPrecision(5));
		set('x_inspect',x.toPrecision(5)); 			set('y_inspect',y.toPrecision(5));
		set('cycle1_part',cycle1.toFixed()); 		set('cycle2_part',cycle2.toFixed());
		set('phase1_part',phase1.toPrecision(3)); 	set('phase2_part',phase2.toPrecision(3));
		set('real1_part',real1.toPrecision(3)); 	set('real2_part',real2.toPrecision(3));
    }
    else
    {
    	hidden('particle_inspection'); hidden('point_inspection');
    }
    context.restore();
}

function drawDblSlitInspector()
{
    var overlap_at_inspector;
    
    if (!inspector) return;
	context.save();
	context.translate(X_inspector, Y_inspector);
	context.beginPath();
	context.arc(0, 0, r_inspector, 0, 2*Math.PI, false);
	context.clip();
	context.fillStyle = 'rgba(255,255,255,0.20)';
	context.fill();
	context.strokeStyle = 'black';
	drawInspectorLine(-r_inspector,0,r_inspector,0);
	drawInspectorLine(0,-r_inspector,0,r_inspector);
	
    overlap_at_inspector = overlapDblSlit(X_inspector, Y_inspector);
    if ((overlap_at_inspector && overlap_only) || (!overlap_only))
    {
        sum.Re = 0; sum.Im = 0; sum.n = 0;
        if (src_waves)  				{drawPhasor(retsrc,		X_inspector, Y_inspector, sum); drawPhasor(advsrc, X_inspector, Y_inspector, sum);}
        if (src_waves && left_slit)  	{drawPhasor(retleft, 	X_inspector, Y_inspector, sum);}
        if (dest_waves && left_slit)	{drawPhasor(advleft, 	X_inspector, Y_inspector, sum);}
        if (src_waves && right_slit)  	{drawPhasor(retright, 	X_inspector, Y_inspector, sum);}
        if (dest_waves && right_slit)	{drawPhasor(advright, 	X_inspector, Y_inspector, sum);}
        if (dest_waves)					{drawPhasor(retdest, 	X_inspector, Y_inspector, sum); drawPhasor(advdest, X_inspector, Y_inspector, sum);}
        context.lineWidth = 3;
        context.strokeStyle = 'white';
        drawInspectorLine(0, 0, sum.Re, -sum.Im);
        context.restore();
    
        context.save();
        context.translate(X_inspector, Y_inspector + r_inspector);
        if (sum.n > 1)   				 drawSumText(Phasor.from_ReIm(sum.Re,sum.Im));
        if (src_waves)  				{drawPhasorText(retsrc, 	X_inspector, Y_inspector); drawPhasorText(advsrc, X_inspector, Y_inspector);}
        if (src_waves && left_slit)  	{drawPhasorText(retleft, 	X_inspector, Y_inspector);}
        if (dest_waves && left_slit)	{drawPhasorText(advleft, 	X_inspector, Y_inspector);}
        if (src_waves && right_slit)  	{drawPhasorText(retright, 	X_inspector, Y_inspector);}
        if (dest_waves && right_slit)	{drawPhasorText(advright, 	X_inspector, Y_inspector);}
        if (dest_waves)					{drawPhasorText(retdest, 	X_inspector, Y_inspector); drawPhasorText(advdest, X_inspector, Y_inspector);}
    }
    context.restore();
}

function drawPhasor(wave, x, y, sum)
{
    var phasor;
	
    if (wave.hasValue(x,y))
    {
        phasor = wave.value(x,y);
        context.lineWidth = 2;
        context.strokeStyle = "hsla(" + phaseHue(phasor.phase) + ",100%,50%,1.0)";
        drawInspectorLine(sum.Re, -sum.Im, sum.Re + phasor.Re(), -(sum.Im + phasor.Im()));
        sum.Re = sum.Re + phasor.Re(); sum.Im = sum.Im + phasor.Im();
        sum.n = sum.n + 1;
    }
}

function drawInspectorLine(x1,y1,x2,y2)
{
    context.beginPath();
    context.moveTo(Math.round(50*x1),Math.round(50*y1));
    context.lineTo(Math.round(50*x2),Math.round(50*y2));
    context.stroke();
}

function drawSumText(sum_phasor)
{
    context.fillStyle = "hsla(" + phaseHue(sum_phasor.phase) + ",100%,50%,1.0)";
    context.translate(0, 20);
    context.font = annotation_font;
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.fillText("Sum:   " + sum_phasor + "   probability density = " + (sum_phasor.modulus*sum_phasor.modulus).toPrecision(5), 0, 0);
}

function drawPhasorText(wave, x, y)
{
    var id;
    var p;
    
    if (wave.hasValue(x,y))
    {
        id = wave.id;
        p = wave.value(x,y);
        context.fillStyle = "hsla(" + phaseHue(p.phase) + ",100%,50%,1.0)";
        context.translate(0, 20);
        context.font = annotation_font;
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(id + ":  " + p, 0, 0);
    }
}

function drawSlits()
{
    context.save();
    context.fillStyle = 'rgb(100,100,100)';
    context.fillRect(0, y_left - w_barrier/2, x_left - w_slit/2, w_barrier);  //left
	if (!left_slit)  // close left slit
	{
		context.fillRect(x_left - w_slit/2, y_left - w_barrier/2, w_slit, w_barrier);
	}
	context.fillRect(x_left + w_slit/2, y_right - w_barrier/2, d_slits - w_slit, w_barrier);  //middle
	if (!right_slit)  // close right slit
	{
		context.fillRect(x_right - w_slit/2, y_right - w_barrier/2, w_slit, w_barrier);
	}
    context.fillRect(x_right + w_slit/2, y_right - w_barrier/2, w - x_right - w_slit/2, w_barrier);  //right
    context.restore();
}

function distance(x1,y1,x2,y2)
{
	//alert("x1,y1 = " + x1 + "," + y1 + "   x2,y2 = " + x2 + "," + y2 + "   d = " + Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)));
	var dx, dy;
	dx = x2 - x1;
	dy = y2 - y1;
	return(Math.sqrt((dx * dx) + (dy * dy)));
}

function HSLtoRGB(H, S, L)  // H : degrees 0 to 360    S, L, R, G, B : 0 to 1
// sets red, green, blue global variables
{
	//alert("H = " + H + "   S = " + S + "   L = " + L);
	var H_prime = H/60;
	//alert("H_prime = " + H_prime);	
	var C = (1 - Math.abs(2*L - 1)) * S;   // chroma
	//alert("C = " + C);
	var X = C * (1 - Math.abs(H_prime % 2 - 1));
	//alert("H_prime % 2 = " + H_prime % 2);
	//alert("X = " + X);
	
	var m = L - C/2;
	//alert("H_prime = " + H_prime + "   C = " + C + "   X = " + X);
	if		(H_prime < 0) 	{red = 0; green = 0; blue = 0; }
	else if (H_prime < 1) 	{red = C; green = X; blue = 0; }
	else if (H_prime < 2) 	{red = X; green = C; blue = 0; }
	else if (H_prime < 3) 	{red = 0; green = C; blue = X; }
	else if (H_prime < 4) 	{red = 0; green = X; blue = C; }
	else if (H_prime < 5) 	{red = X; green = 0; blue = C; }
	else if (H_prime < 6) 	{red = C; green = 0; blue = X; }
	else 					{red = 0; green = 0; blue = 0; }
	red = red + m;
	green = green + m;
	blue = blue + m;
	//alert("red = " + red + "   green = " + green + "   blue = " + blue);
}

function rgbaMag(mag)
{
	var r, g, b, a, opacity;
	
	r = Math.floor(mag * 255);
	g = Math.floor(mag * 255);
	b = Math.floor(mag * 255);
	opacity = 0.2;
	a = opacity * 255;
	return (a << 24) | (b << 16) | (g << 8) | r;
}

function rgbaPhasor(p)
{
	var r, g, b, a, opacity;
	
	HSLtoRGB(phaseHue(p.phase),1,0.5);
	//alert("red = " + red + "   green = " + green + "   blue = " + blue);
	r = Math.floor(red * 255);
	g = Math.floor(green * 255);
	b = Math.floor(blue * 255);
	opacity = p.modulus;
	if (opacity > 1) {a = 255; } else {a = opacity * 255; }
	return (a << 24) | (b << 16) | (g << 8) | r;
}

function phaseHue(phase) // express hue as degrees 0 to 360
{
	var angle = (phase*180/Math.PI) % 360;
	if (angle < 0) angle = 360 + angle;
	return angle;
}

// add Phasor p to sum
function sumPhasor(p)
{
	sum.Re = sum.Re + p.Re(); sum.Im = sum.Im + p.Im();
	sum.n = sum.n + 1;
}

// calculate sum for a location above slits
function upperSum(x,y)
{
	var k = y * w + x;
	var d1 = Uleft_Float64[k];
	var d2 = Uright_Float64[k];
	var d3 = Udest_Float64[k];
    
	sum.Re = 0; sum.Im = 0; sum.n = 0;  // clear sum
	if (retleft.onLightCone(d1)  && ret_waves && left_slit)		{sumPhasor(retleft.phasor(d1));}
	if (retright.onLightCone(d2) && ret_waves && right_slit)	{sumPhasor(retright.phasor(d2));}
	if (retdest.onLightCone(d3)  && ret_waves && dest_waves)	{sumPhasor(retdest.phasor(d3));}
	if (advdest.onLightCone(d3)  && adv_waves && dest_waves)	{sumPhasor(advdest.phasor(d3));}
	//alert(p_result + "  n = " + n);
    if (overlap_only && sum.n == 1) return 0; else return sum.n; 
}

// calculate sum for a location below slits
function lowerSum(x,y)
{
	var k = (y - half_h) * w + x;
	var d1 = Lsrc_Float64[k];
	var d2 = Lleft_Float64[k];
	var d3 = Lright_Float64[k];
    
	sum.Re = 0; sum.Im = 0; sum.n = 0;
	if (retsrc.onLightCone(d1) && ret_waves && src_waves)	{sumPhasor(retsrc.phasor(d1));}
	if (advsrc.onLightCone(d1) && adv_waves && src_waves)	{sumPhasor(advsrc.phasor(d1));}
	if (advleft.onLightCone(d2) && adv_waves && left_slit)	{sumPhasor(advleft.phasor(d2));}
	if (advright.onLightCone(d3) && adv_waves && right_slit){sumPhasor(advright.phasor(d3));}
	if (overlap_only && sum.n == 1) return 0; else return sum.n; 
}

// turn sum into rgba integer at location k
function setBuffer(k)
{
	p_result.from_ReIm(sum.Re, sum.Im);
	image_buffer_32[k] = rgbaPhasor(p_result);
}

function setUpperPattern(buffer_32)
{
	var k,x,y;
	
	k = 0;
	for (y = 0; y < half_h; y++)
	{
		for (x = 0; x < w; x++)
		{
            buffer_32[k] = rgbaMag(Upattern(x,y));
			k++;
		}
	}
}

function setLowerPattern(buffer_32)
{
	var k,x,y;
	
	k = 0;
	for (y = half_h; y < h; y++)
	{
		for (x = 0; x < w; x++)
		{
            buffer_32[k] = rgbaMag(Lpattern(x,y));
			k++;
		}
	}
}

function modulusSum(d_left, d_right)
{
    var delta_d, lambda, phase_left, phase_right;
    var p_left, p_right, p_sum;
    
    delta_d = Math.abs(d_left - d_right);
    lambda = 1/frequency;
    phase_left = ((d_left % lambda)/lambda)*2*Math.PI;
    phase_right = ((d_right % lambda)/lambda)*2*Math.PI;
    p_left = new Phasor(0.5, phase_left);
    p_right = new Phasor(0.5, phase_right);
    p_sum = new Phasor.sum(p_left, p_right);
    return (p_sum.modulus); 
}

function Upattern(x, y)
{
    var d_left, d_right;
    
    d_left =  distance(x_src,y_src,x_left,y_left) +   distance(x_left,y_left,x,y);
    d_right = distance(x_src,y_src,x_right,y_right) + distance(x_right,y_right,x,y);
    return (modulusSum(d_left, d_right)); 
}

function Lpattern(x, y)
{
    var d_left, d_right;
    
    d_left =  distance(x_dest,y_dest,x_left,y_left) +   distance(x_left,y_left,x,y);
    d_right = distance(x_dest,y_dest,x_right,y_right) + distance(x_right,y_right,x,y);
    return (modulusSum(d_left, d_right)); 
}

// draw pixels above slits to image buffer
function drawUpper()
{
	var k,x,y;
	
	k = 0;
	for (y = 0; y < half_h; y++)
	{
		for (x = 0; x < w; x++)
		{
			if (upperSum(x, y) > 0) setBuffer(k);
			k++;
		}
	}
}

// draw pixels below slits to image buffer
function drawLower()
{
	var k,x,y;
	
	k = w * half_h;
	for (y = half_h; y < h; y++)
	{
		for (x = 0; x < w; x++)
		{
			if (lowerSum(x, y) > 0) setBuffer(k);
			k++;
		}
	}
}

function drawDblSlitWaves()
{
    if (pattern && !dest_waves) image_buffer_8.set(upper_buffer_8);
    else image_buffer_8.set(blank_buffer_8);
    if (pattern && !src_waves) image_buffer_8.set(lower_buffer_8,w*half_h*4);
    else image_buffer_8.set(blank_buffer_8, w*half_h*4);
	drawUpper();                            // draw waves to image_buffer_8 above slits
	drawLower();                            // draw waves to image_buffer_8 below slits
	image_data.set(image_buffer_8);			// copy image_buffer_8 to image_data
	context.putImageData(imageData, 0, 0);  // copy imageData to context pixels
}

function drawSrcDest()
{
	context.fillStyle = 'yellow';
	context.fillRect(x_src-1,y_src-1,2,2);
	context.fillRect(x_dest-1,y_dest-1,2,2);
}

function drawDblSlit()
{
    overlap_only = On("overlap_checkbox");
    left_slit = On("left_slit_checkbox");
    right_slit = On("right_slit_checkbox");
    inspector = On("inspector_checkbox");
    ret_waves = On("retarded_checkbox");
    adv_waves = On("advanced_checkbox");
    src_waves = On("source_waves_checkbox");
    dest_waves = On("destination_waves_checkbox");
    pattern = On("pattern_checkbox");
	
    drawDblSlitWaves();
    drawSlits();
    drawSrcDest();
    drawDblSlitInspector();
}

function setAlpha(rgbaColorString, newAlpha)
{
  const parts = rgbaColorString.match(/\d+(\.\d+)?/g); // Extract numbers
  if (parts && parts.length === 4)
  {
    const r = parts[0];
    const g = parts[1];
    const b = parts[2];
    return `rgba(${r}, ${g}, ${b}, ${newAlpha})`;
  }
  return rgbaColorString; // Return original if format is incorrect
}

function dt1(v, dx, dy) {return (( v*dx + Math.sqrt((c*c-v*v)*(dy*dy) + c*c*dx*dx))/(c*c-v*v));}
function dt2(v, dx, dy) {return ((-v*dx + Math.sqrt((c*c-v*v)*(dy*dy) + c*c*dx*dx))/(c*c-v*v));}

function drawPixelPair(dx,dy) // particle moves parallel to x-axis
{
	var color;
	var X,Y;

	dt_1 = dt1(v, dx, dy); // t - t1
	dt_2 = dt2(v, dx, dy); // t2 - t
	x1 = x_particle - v*dt_1; // position of particle at event 1
	x2 = x_particle + v*dt_2; // position of particle at event 2
	t1 = t - dt_1; // stationary time retarded wave left moving particle
	t2 = t + dt_2; // stationary time advanced wave will leave moving particle
	phase1 = omega*(t1/gamma) % (2*Math.PI); // adjusted to moving particle's slower clock
	phase2 = (omega*(t2/gamma) + Math.PI) % (2*Math.PI); // adjusted to moving particle's slower clock
	real1 = Math.sin(phase1)/2; real2 = Math.sin(phase2)/2; // normalized to real values between -1 and 1
	if (ret_waves && adv_waves) {real = real1 + real2;}
	else if (ret_waves && !adv_waves) {real = real1;}
	else if (!ret_waves && adv_waves) {real = real2;}
	//console.log("    t1=" & t1 & "    t2=" & t2 & "    phase1 =" & phase1 & "phase2=" & phase2 & "    real1=" & real1 & "    real2=" & real2 & "    real=" & real);
	if (real >= 0) 	{color = "rgba(0,0,255,1)";}
	else 			{color = "rgba(255,255,0,1)";}
	context.fillStyle = setAlpha(color,Math.abs(real));
	X = x_to_X(x_particle + dx); Y = y_to_Y(y_particle + dy);
	context.fillRect(X,Y,1,1);
	if (dy > 0) context.fillRect(X,y_to_Y(y_particle - dy),1,1);
}

function drawFreeWaves()
{
	var dx,dy;
	var X_particle,Y_particle;
	var X,Y;

	X_particle = x_to_X(x_particle); Y_particle = y_to_Y(y_particle);
	X = X_particle - X_delta;
	while (X < X_particle + X_delta)
	{
		dx = X_to_x(X) - x_particle; 
		Y = Y_particle - Y_delta; // positive dy is negative dY
		while (Y <= Y_particle)
		{
			dy = Y_to_y(Y) - y_particle;
			drawPixelPair(dx,dy); // both +dy and -dy are drawn
			Y = Y + 1;
		}
		X = X + 1;
	}
}

function drawFreeParticle() {fillCircle(x_to_X(x_particle),y_to_Y(y_particle),2,"white");}

function drawFreeNotation()
{
	var dB_wavelength,dx1,dx2,u;
	var dX1,dX2,X1,Y1,X2,Y2; // screen coord. (Y increases downward)

	if (!notation) {return;}
	X1 = x_to_X(x_particle); Y1 = y_to_Y(y_particle);
	X2 = X1 + 150; Y2 = Y1 - 150;
	drawLine(X1,Y1,X2,Y2,3,'white');
	drawText("particle speed = v = " + v.toPrecision(3) + " c",X2,Y2,'left','middle',0);
	drawText("particle frequency = mc\u00B2/(\u03B3h) = (Compton frequency)/\u03B3",X2,Y2+20,'left','middle',0);
	if (v == 0)
	{
		drawLine(X1,Y1,X1,Y1+Y_delta+20,3,'white');
		drawLine(X1+scale*fps,Y1,X1+scale*fps,Y1+Y_delta+20,3,'white');
		drawText("Compton wavelength = h/(mc)",X1+scale/2,Y1+Y_delta+25,'center','top');
		drawText("Compton frequency = mc\u00B2/h",X1+scale/2,Y1+Y_delta+45,'center','top');
		drawText("Compton wave speed = c",X1+scale/2,Y1+Y_delta+65,'center','top');
		if (ret_waves && adv_waves) {drawText("(retarded + advanced = standing Compton wave)",X1+scale/2,Y1+Y_delta+85,'center','top');}
	}
	else if(ret_waves && adv_waves)
	{
		u = c/v;
		dB_wavelength = 1/(v*gamma); // relativistic de Broglie wavelength
		dx2 = ((u-v)*t/fps + 3*dB_wavelength/4) % (dB_wavelength); dx1 = dB_wavelength - dx2;
		dX1 = scale*dx1*fps; dX2 = scale*dx2*fps;
		drawLine(X1-dX1,Y1+Y_delta,		X1-dX1,Y1+Y_delta+20,3,'white');
		drawLine(X1-dX1,Y1+Y_delta+10,	X1+dX2,Y1+Y_delta+10,3,'white');
		drawLine(X1+dX2,Y1+Y_delta,		X1+dX2,Y1+Y_delta+20,3,'white');
		drawText("de Broglie wavelength = h/(\u03B3mv)",X1,Y1+Y_delta+25,'center','top');
		drawText("de Broglie frequency = \u03B3mc\u00B2/h",X1,Y1+Y_delta+45,'center','top');
		drawText("de Broglie wave speed = c\u00B2/v = " + (1/v).toPrecision(3) + " c",X1,Y1+Y_delta+65,'center','top');
	}
}

function drawFree()
{
	var controls_visibility;

	set('time',t.toPrecision(5));
	point_inspector = On('point_inspector_checkbox');
	particle_inspector = On('particle_inspector_checkbox');
	inspector = particle_inspector || point_inspector;
    ret_waves = On('retarded_checkbox');
    adv_waves = On('advanced_checkbox');
    notation = On('notation_checkbox');

    x_particle = x_particle_start + v*t;
    set('x_particle',x_particle.toPrecision(5)); set('y_particle',0);
    canvas.width = w;  //clears the canvas
  	canvas.height = h; //clears the canvas
  	controls_visibility = $i('freeparticle_controls').style.visibility;
    drawFreeWaves();
    drawFreeParticle();
    drawFreeInspector();
    drawFreeNotation();
    $i('freeparticle_controls').style.visibility = controls_visibility;
}

function drawFrame()
{
	if (mode == 'dblslit') drawDblSlit();
	else if (mode == 'free') drawFree();
}

function animate()
{
    if (!paused) {t = t + delta_t;}
    drawFrame();
}

// compute distances from source of wave (x0,y0) to all pixels above slits
function upperDistances(x0, y0, upperarray)
{
	var x, y;
	for (x = 0; x < w; x++)
	{
		for (y = 0; y < half_h; y++)
		{
			upperarray[y * w + x] = distance(x0, y0, x, y);
		}
	}
}

// compute distances from source of wave (x0,y0) to all pixels below slits
function lowerDistances(x0, y0, lowerarray)
{
	var x, y;
	for (x = 0; x < w; x++)
	{
		for (y = half_h; y < h; y++)
		{
			lowerarray[(y - half_h) * w + x] = distance(x0, y0, x, y);
		}
	}
}

function resize(init)
{
	var t_dest_left, t_dest_right;

	//alert("resize");
    w_full = Math.floor(document.documentElement.clientWidth);
    h_full = Math.floor(document.documentElement.clientHeight);
    if (isEven(w_full)) w = w_full; else w = w_full-1;
    if (isEven(h_full)) h = h_full; else h = h_full-1;
	
	//starttext.width = w_full; starttext.height = h_full;
    canvas.width = w;		//clears the canvas
    canvas.height = h;		//clears the canvas
	
	//context.translate(w/2, h/2); 			//define origin of coordinate system to be in center of canvas
	//context.translate(w/2, h/2);	//same origin as drawing context
    
    canvas_x = 0;
    canvas_y = 0;
	
	half_w = Math.round(w/2);
	half_h = Math.round(h/2);

	// free particle info
	x_particle_start = 0; y_particle = 0; //starting point for free particle

    // double slit info
	w_barrier = 4; w_slit = 4; d_slits = 100;
	x_left =  Math.round(half_w - d_slits/2); y_left =  half_h;
	x_right = Math.round(half_w + d_slits/2); y_right = half_h;
    
    if (init) {dX_inspector = 0; dY_inspector = 0;}
    X_inspector = half_w + dX_inspector; Y_inspector = half_h + dY_inspector;
    x_inspector = X_to_x(X_inspector); y_inspector = Y_to_y(Y_inspector);
    
    if (init) {dx_src = 100; dy_src = 100; dx_dest = -100; dy_dest = -100;}
    x_src =  half_w + dx_src;  y_src =  half_h + dy_src;
    x_dest = half_w + dx_dest; y_dest = half_h + dy_dest;

    t_retsrc = 0;
	t_retleft = distance(x_src, y_src, x_left, y_left);
	t_retright = distance(x_src, y_src, x_right, y_right);
	t_dest_left =  t_retleft +  distance(x_left,  y_left,  x_dest, y_dest);
    t_dest_right = t_retright + distance(x_right, y_right, x_dest, y_dest);
    coherence_time = min_coherence_time + Math.abs(t_dest_left - t_dest_right);
    t_advsrc = coherence_time;
    t_retdest = Math.max(t_dest_left,t_dest_right);
    t_advdest= t_retdest + coherence_time;
    t_advleft = t_retleft + coherence_time;
    t_advright = t_retright + coherence_time;
	
	d_left =  t_retleft;
	d_right = t_retright;
    
    imageData = context.getImageData(0, 0, w, h);				// imageData Object representing context pixels
	image_data = imageData.data;								// Uint8ClampedArray representing a one-dimensional array of image data in RGBA order
	image_buffer = new ArrayBuffer(image_data.length);			// ArrayBuffer with same number of bytes as image_data array
	image_buffer_8 = new Uint8ClampedArray(image_buffer);		// Typed Array View of image_buffer as unsigned 8 bit integers (clamped to 0 through 255)
	image_buffer_32 = new Uint32Array(image_buffer);			// Typed Array View of image_buffer as unsigned 32 bit integers
    
    blank_buffer = new ArrayBuffer(image_data.length/2);		// ArrayBuffer with half the number of bytes as image_data array
	blank_buffer_8 = new Uint8ClampedArray(blank_buffer);	    // Typed Array View of blank_buffer as unsigned 8 bit integers (clamped to 0 through 255)
    
    upper_buffer = new ArrayBuffer(image_data.length/2);		// ArrayBuffer with half the number of bytes as image_data array
	upper_buffer_8 = new Uint8ClampedArray(upper_buffer);	    // Typed Array View of upper_buffer as unsigned 8 bit integers (clamped to 0 through 255)
	upper_buffer_32 = new Uint32Array(upper_buffer);		    // Typed Array View of upper_buffer as unsigned 32 bit integers
    
    lower_buffer = new ArrayBuffer(image_data.length/2);		// ArrayBuffer with half the number of bytes as image_data array
	lower_buffer_8 = new Uint8ClampedArray(lower_buffer);	    // Typed Array View of lower_buffer as unsigned 8 bit integers (clamped to 0 through 255)
	lower_buffer_32 = new Uint32Array(lower_buffer);		    // Typed Array View of lower_buffer as unsigned 32 bit integers
    
    setUpperPattern(upper_buffer_32);
    setLowerPattern(lower_buffer_32);
	
    // function Wave(   waveid, 											retarded, 	src_side, 	t0, 		x0, 	y0, 		modulus0, 	phase0)
	retsrc =   new Wave("Retarded Wave from Source", 						true, 		true, 		t_retsrc, 	x_src, 	y_src, 		0.5, 		0);
    retleft =  new Wave("Retarded Wave from Source through Left Slit", 		true, 		false, 		t_retleft, 	x_left,	y_left, 	0.5, 		0);
    retright = new Wave("Retarded Wave from Source through Right Slit", 	true, 		false, 		t_retright,	x_right,y_right,	0.5, 		0);
	retdest =  new Wave("Retarded Wave from Destination", 					true, 		false, 		t_retdest, 	x_dest, y_dest, 	0.5, 		Math.PI);
    advsrc =   new Wave("Advanced Wave from Source", 						false, 		true, 		t_advsrc, 	x_src, 	y_src, 		0.5, 		0);
    advleft =  new Wave("Advanced Wave from Destination through Left Slit", false, 		true, 		t_advleft, 	x_left, y_left, 	0.5, 		0);
    advright = new Wave("Advanced Wave from Destination through Right Slit",false, 		true, 		t_advright,	x_right,y_right, 	0.5, 		0);
    advdest =  new Wave("Advanced Wave from Destination", 					false, 		false, 		t_advdest, 	x_dest, y_dest, 	0.5, 		Math.PI);

    
	// initialize distances
	Lsrc = new ArrayBuffer(w * half_h * 8);
	Lleft = new ArrayBuffer(w * half_h * 8);
	Lright = new ArrayBuffer(w * half_h * 8);
    Uleft = new ArrayBuffer(w * half_h * 8);
	Uright = new ArrayBuffer(w * half_h * 8);
	Udest = new ArrayBuffer(w * half_h * 8);

	Lsrc_Float64 = new Float64Array(Lsrc);
	Lleft_Float64 = new Float64Array(Lleft);
    Lright_Float64 = new Float64Array(Lright);
	Uleft_Float64 = new Float64Array(Uleft);
	Uright_Float64 = new Float64Array(Uright);
	Udest_Float64 = new Float64Array(Udest);

	lowerDistances(x_src, y_src, Lsrc_Float64);
	lowerDistances(x_left, y_left, Lleft_Float64);
    lowerDistances(x_right, y_right, Lright_Float64);
	upperDistances(x_left, y_left, Uleft_Float64);
    upperDistances(x_right, y_right, Uright_Float64);
	upperDistances(x_dest, y_dest, Udest_Float64);
	
    drawFrame();
}

function reset() {t = 0; delta_t = 1; t0_inspector = 0; x0_inspector = 0; if (paused) drawFrame();}

function load()
{
	controls = $i('controls');
	dblslit_controls = $i('dblslit_controls');
    freeparticle_controls = $i('freeparticle_controls');
	canvas = $i('canvas');
	context = canvas.getContext('2d');
	hidden('controls');
    hidden('dblslit_controls');
    hidden('freeparticle_controls');
    hidden('canvas');
    inherit('start');
    started = false;
}

function exit()
{
	hidden('controls');
    hidden('dblslit_controls');
    hidden('freeparticle_controls');
    hidden('canvas');
    inherit('start');
}

function init()
{
	c = 1;
	v = 0; set('v_over_c',"0");
	u = c*c/v; set('u_over_c',"Infinity");
  	gamma = 1; set('gamma',"1");
  	omega = 2*Math.PI/fps; // slowed so no strobe effect
  	scale = 1;
  	delta_t = 1;
  	t0_inspector = 0;
  	setTitles();

  	document.querySelector('#speed_range').value = 0;

	//context.beginPath();
    //context.rect(0, 0, w, h);
    //context.clip();  //no drawing outside canvas

	P_mousedown.x = 0; P_mousedown.y = 0;
    	
	min_coherence_time = 30;
	frequency = 0.1;

	notation = false; $i('notation_checkbox').checked = false;
	point_inspector = false; $i('point_inspector_checkbox').checked = false;
	particle_inspector = false; $i('particle_inspector_checkbox').checked = false;
    pattern = false; $i('pattern_checkbox').checked = false;
    ret_waves = true; $i('retarded_checkbox').checked = true;
	adv_waves = true; $i('advanced_checkbox').checked = true;
	left_slit = true; $i('left_slit_checkbox').checked = true;
	right_slit = true; $i('right_slit_checkbox').checked = true;
	src_waves = true; $i('source_waves_checkbox').checked = true;
	dest_waves = true; $i('destination_waves_checkbox').checked = true;
	inspector_motion = 'stationary'; $i('stationary_button').checked = true;
	//mode = '';

    //$i('arcs_checkbox').checked = false; $i('arcs_span').style.visibility = "hidden";
    paused = false; $i("pause_resume_button").innerHTML="pause ";
    hidden('single_steps');
    hidden('set_srcdest');
    $i('overlap_checkbox').checked = false;
    hidden('single_steps');
    $i('forward_button').checked = true;
	//$i('scale_checkbox').checked = false; $i('rotate_checkbox').checked = false;
    prev_P_mouseup.x = 0; prev_P_mouseup.y = 0;
    //$i("real_button").checked = true;

    resize(true);
	reset();
}

function start(mode_setting)
{
    var animate_func = 'animate()';
	msec_delay = 1000/fps;
    init();
	frame_timerID = setInterval(animate_func, msec_delay);
	started = true;
	mode = mode_setting;
	if (mode == 'dblslit') r_inspector = 100;
	else if (mode == 'free') r_inspector = 20;
}

var button_timer;
function holdButtonOn(delay, action)
{
  var repeat = function () {action(); drawFrame(); button_timer = setTimeout(repeat, delay);};
  repeat();
}
function holdButtonOff() {clearTimeout(button_timer);}

//buttons
function description()  {hidden('start'); inherit('description');}
function derivation()	{hidden('description'); inherit('derivation');}
function return_from_derivation() {hidden('derivation'); inherit('description');}
function UI()           {hidden('start'); inherit('UI');}
function return_to_start()
{
  window.scrollTo(0,0);
  hidden('description');
  //hidden('FAQ');
  hidden('UI');
  hidden('canvas');
  hidden('controls');
  inherit('start');
}
function dblslitButton() 		{start('dblslit'); hidden('start'); inherit('canvas');}
function freeButton() 			{start('free'); hidden('start'); inherit('canvas');}

function pause_resumeButton()
{
    var animate_func = 'animate()';

	paused = !paused;
	if(paused) {clearInterval(frame_timerID); $i("pause_resume_button").innerHTML="resume"; inherit('single_steps'); inherit('set_srcdest');}
	else {frame_timerID = setInterval(animate_func,msec_delay); $i("pause_resume_button").innerHTML="pause "; hidden('single_steps'); hidden('set_srcdest');}
	drawFrame();
}

function forwardButton()  		{delta_t = Math.abs(delta_t); $i('forward_button').checked = true;show_table_column('point_table',1,true); drawFrame();}
function backwardButton() 		{delta_t = -Math.abs(delta_t); show_table_column('point_table',1,false); $i('backward_button').checked = true; drawFrame();}
function stationaryButton()		{inspector_motion = "stationary";}
function particleButton()		{inspector_motion = "particle"; t0_inspector = t; x0_inspector = x_inspector;}
function deBroglieButton()		{inspector_motion = "de Broglie"; t0_inspector = t; x0_inspector = x_inspector;}

function fasterButton() 		{delta_t = delta_t*2;}
function slowerButton() 		{delta_t = delta_t/2;}

function sourceButton() 		{setting_source = true;}
function destinationButton() 	{setting_destination = true;}

function stepbackwardButton() 	{if (paused) {dt = delta_t; delta_t = -Math.abs(delta_t); paused = false; animate(); paused = true; delta_t = dt;}}
function stepforwardButton()  	{if (paused) {dt = delta_t; delta_t = Math.abs(delta_t);  paused = false; animate(); paused = true; delta_t = dt;}}

function stepbackward_down()	{holdButtonOn(200, stepbackwardButton);}
function stepbackward_up()     	{holdButtonOff();}
function stepforward_down()    	{holdButtonOn(200, stepforwardButton);}
function stepforward_up()      	{holdButtonOff();}

function zoom_out_down()       	{holdButtonOn(100, function() {scale = scale*0.99;});}
function zoom_out_up()         	{prev_scale = scale; holdButtonOff();}
function zoom_zero()           	{scale = 1; prev_scale = 1; drawFrame();}
function zoom_in_down()        	{holdButtonOn(100, function() {scale = scale*1.01;});}
function zoom_in_up()          	{prev_scale = scale; holdButtonOff();}

function complexButton()		{complex = true;}
function realButton()			{complex = false;}
	
// event handlers

function control_input(target)
{
  return(target.type=='submit' || target.type=='button' || target.type=='checkbox' || target.type=='radio' || target.type=='range' || target.tagName=='SPAN' || target.tagName=='TD');
}

function mouseClick()
{
    if (control_input(event.target)) return;
    if (setting_source) {setting_source = false; return;}
    if (setting_destination) {setting_destination = false; return;}
    if ((P_mouseup.x == prev_P_mouseup.x) || (P_mouseup.y == prev_P_mouseup.y)) return;
    if ((Math.abs(P_mouseup.x - P_mousedown.x) > 0) || (Math.abs(P_mouseup.y - P_mousedown.y) > 0)) return;
    if (mode == 'dblslit')
    {
		if (controls.style.visibility=='hidden') {inherit('controls'); inherit('dblslit_controls');} else {hidden('controls'); hidden('dblslit_controls');}
	}
	else if (mode == 'free')
	{
		if (controls.style.visibility=='hidden') {inherit('freeparticle_controls'); inherit('controls');} else {hidden('controls'); hidden('freeparticle_controls');}
	}
	if (started) drawFrame();
}

function mouseDown(event)
{
	if (control_input(event.target)) return;
    P_mousedown.x = event.pageX; P_mousedown.y = event.pageY;
	dragging_inspector = inspector && (distance(x_to_X(x_inspector),y_to_Y(y_inspector), event.pageX,event.pageY) <= r_inspector) && (event.button==0);
    if (setting_source &&      (event.pageY > half_h) && (event.button==0))
    {
        x_src = event.pageX; dx_src = x_src - half_w;
        y_src = event.pageY; dy_src = y_src - half_h;
        resize(false); reset(); drawFrame();
    }
    if (setting_destination && (event.pageY < half_h) && (event.button==0))
    {
        x_dest = event.pageX; dx_dest = x_dest - half_w;
        y_dest = event.pageY; dy_dest = y_dest - half_h;
        resize(false); reset(); drawFrame();
    }
}
function mouseMove(event)
{
    if (control_input(event.target)) return;
    if (dragging_inspector)
    {
        X_inspector = event.pageX; Y_inspector = event.pageY;
        x_inspector = X_to_x(X_inspector); y_inspector = Y_to_y(Y_inspector);
        dX_inspector = X_inspector - half_w;
        dY_inspector = Y_inspector - half_h;
        t0_inspector = t; x0_inspector = x_inspector;
        drawFrame();
    }
}
function mouseUp(event)
{
    if (control_input(event.target)) return;
    P_mouseup.x = event.pageX; P_mouseup.y = event.pageY;
    dragging_inspector = false;
    if ((P_mouseup.x == P_mousedown.x) && (P_mouseup.y == P_mousedown.y) && !control_input(event.target))
        {mouseClick(); prev_P_mouseup.x = 0; prev_P_mouseup.y = 0;}
    else {prev_P_mouseup.x = P_mouseup.x; prev_P_mouseup.y = P_mouseup.y;}
}

function touchStart(event)
{
  if (event.target.type != "range") event.preventDefault();
	if (buttonClick(event))
	{
		drawFrame();
	}
	else
	{
		event.button = 0;
		mouseDown(event);
	}
}
function touchMove(event)
{
  if (event.target.type != "range") event.preventDefault();
  mouseMove(event);
}
function touchEnd(event)
{
  if (event.target.type != "range") event.preventDefault();
  mouseUp(event);
}

function gestureStart(event) { if (started && event.target.id == 'canvas') gesture = true; }
function gestureChange(event)
{
	if (started && gesture)
	{
		if (scaling_enabled) scale = prev_scale*event.scale;
		if (rotation_enabled) { rotation = event.rotation; calcRotation(rotation*Math.PI/180); }
		if (scaling_enabled || rotation_enabled) drawFrame();
    event.preventDefault();
	}
}
function gestureEnd() { if (started) {gesture = false; prev_scale = scale; prev_theta = theta; } }

function targetType(event,value) { return(event.target.type == value || event.target.parentElement.type == value); }

function is_touch_enabled()
{
    return ( 'ontouchstart' in window ) ||
           ( navigator.maxTouchPoints > 0 ) ||
           ( navigator.msMaxTouchPoints > 0 );
}

function buttonClick(event)
{
	if (is_touch_enabled())
		return (event.type == "touchstart") && (targetType(event,"button") || targetType(event,"radio") || targetType(event,"checkbox"));
	else
		return (event.type == "click")      && (targetType(event,"button") || targetType(event,"radio") || targetType(event,"checkbox"));
}

function change() {drawFrame();}

/*function zoom(key)
{
	if (!started || !paused) {return;}
	if (key == "+" || key == "=") 		{scale = scale*1.01;}
	else if (key == "-" || key == "_") 	{scale = scale*0.99;}
	drawFrame();
}*/

function arrow(dX,dY) // move Inspector one pixel in X,Y coord
{
	if (inspector)
	{
		console.log("before  X_inspector = " + X_inspector + " x_inspector = " + x_inspector + " x0_inspector = " + x0_inspector);
		X_inspector = X_inspector + dX;
		Y_inspector = Y_inspector + dY;
		x_inspector = X_to_x(X_inspector); y_inspector = Y_to_y(Y_inspector);
		x0_inspector = x_inspector; t0_inspector = t;
		console.log("after  X_inspector = " + X_inspector + " x_inspector = " + x_inspector + " x0_inspector = " + x0_inspector);
		drawFrame();
	}
}

// capture:false means use bubble up, passive:false means allow preventDefault

canvas = $i('canvas');
canvas.addEventListener("gesturestart",    gestureStart,   {capture:false, passive:false});
canvas.addEventListener("gesturechange",   gestureChange,  {capture:false, passive:false});
canvas.addEventListener("gestureend",      gestureEnd,     {capture:false, passive:false});
canvas.addEventListener("touchstart",      touchStart,     {capture:false, passive:false});
canvas.addEventListener("touchmove",       touchMove,      {capture:false, passive:false});
canvas.addEventListener("touchend",        touchEnd,       {capture:false, passive:false});
canvas.addEventListener("mousedown",       mouseDown,      {capture:false, passive:false});
canvas.addEventListener("mousemove",       mouseMove,      {capture:false, passive:false});
canvas.addEventListener("mouseup",         mouseUp,        {capture:false, passive:false});

controls = $i('controls');
controls.addEventListener("change",		change,         {capture:false, passive:false});
controls.addEventListener("touchstart", touchStart,     {capture:false, passive:false});
controls.addEventListener("touchmove",  touchMove,      {capture:false, passive:false});
controls.addEventListener("touchend",   touchEnd,       {capture:false, passive:false});
controls.addEventListener("mousedown",  mouseDown,      {capture:false, passive:false});
controls.addEventListener("mousemove",  mouseMove,      {capture:false, passive:false});
controls.addEventListener("mouseup",    mouseUp,        {capture:false, passive:false});

document.addEventListener("keydown", function(e)
{
/*  if (e.ctrlKey || e.metaKey) // Check for Ctrl (Windows) or Command (Mac) key
  {
    const zoomKeys = ["+", "-", "_", "="]; // keys associated with zoom
    if (zoomKeys.includes(e.key)) {e.preventDefault(); zoom(e.key);}
  }*/
  if 		(e.key == "ArrowRight")	{arrow(1,0);}
  else if 	(e.key == "ArrowLeft") 	{arrow(-1,0);}
  else if 	(e.key == "ArrowUp") 	{arrow(0,-1);}
  else if 	(e.key == "ArrowDown") 	{arrow(0,1);}
});

function toggleCheckbox(event)
{
  var node;
  var count;
  if (event.target.nodeName == "SPAN")
  {
    count = event.currentTarget.childElementCount;
    for (let i = 0; i < count; i++)
    {
      node = event.currentTarget.childNodes[i];
      if (node.nodeName == "INPUT")
      {
      	node.checked = !node.checked; drawFrame(); return;}
    }
  }
  else drawFrame();
}

function toggleInspector(event)
{
	if 		(event.target.id == 'point_inspector_checkbox') 	{$i('particle_inspector_checkbox').checked = false;}
	else if (event.target.id == 'point_inspector') 				{$i('point_inspector_checkbox').checked = !$i('point_inspector_checkbox').checked; 			$i('particle_inspector_checkbox').checked = false;}
	else if (event.target.id == 'particle_inspector_checkbox') 	{$i('point_inspector_checkbox').checked = false;}
	else if (event.target.id == 'particle_inspector') 			{$i('particle_inspector_checkbox').checked = !$i('particle_inspector_checkbox').checked; 	$i('point_inspector_checkbox').checked = false;}
	drawFrame();
}

function setValue(id)
{
	var value;

	if (!paused) return;
	if 		(id == 'time') 			value = t;
	else if (id == 'v_over_c') 		value = v;
	else if (id == 'u_over_c') 		value = c*c/v;
	else if (id == 'gamma') 		value = gamma;
	else if (id == 'x_particle')	value = x_particle;
	else if (id == 'r1') 			value = r1;
	else if (id == 'r2') 			value = r2;
	else if (id == 'real') 			value = real;
	else if (id == 'dx') 			value = dx;
	else if (id == 'dy') 			value = dy;
	else if (id == 'x_inspect')		value = x;
	else if (id == 'y_inspect') 	value = y;
	else if (id == 'dt1') 			value = dt_1;
	else if (id == 'dt2') 			value = dt_2;
	else if (id == 't1') 			value = t1;
	else if (id == 't2') 			value = t2;
	else if (id == 'x1') 			value = x1;
	else if (id == 'x2')			value = x2;
	else if (id == 'cycle1') 		value = cycle1;
	else if (id == 'cycle2') 		value = cycle2;
	else if (id == 'phase1') 		value = phase1;
	else if (id == 'phase2') 		value = phase2;
	else if (id == 'real1') 		value = real1;
	else if (id == 'real2') 		value = real2;
	else if (id == 't_part') 		value = t_particle;
	else if (id == 'cycle1_part') 	value = cycle1;
	else if (id == 'cycle2_part') 	value = cycle2;
	else if (id == 'phase1_part') 	value = phase1;
	else if (id == 'phase2_part') 	value = phase2;
	else if (id == 'real1_part') 	value = real1;
	else if (id == 'real2_part') 	value = real2;
	if (id == 't1' || id == 't2') $i(id).title = value + "\n[Click to jump to this time]";
	else $i(id).title = value;
}

function setTitle(id)
{
	var title;

	if 		(id == 'time') 			title = "current time\n[Click to change value]";
	else if (id == 'v_over_c') 		title = "group velocity as fraction of c (0 <= v/c < 1)\n[Click to change value]";
	else if (id == 'u_over_c') 		title = "phase velocity as fraction of c\n[Click to change value]";
	else if (id == 'gamma') 		title = "Lorentz factor: ratio for length contraction and time dilation\n[Click to change value]";
	else if (id == 'x_particle')	title = "x coordinate of particle";
	else if (id == 'r1') 			title = "distance from retarded wave origin to inspection point";
	else if (id == 'r2') 			title = "distance from advanced wave origin to inspection point";
	else if (id == 'real') 			title = "sum of real amplitudes of retarded and advanced waves";
	else if (id == 'dx') 			title = "x distance from particle to inspection point";
	else if (id == 'dy') 			title = "y distance from particle to inspection point";
	else if (id == 'x_inspect')		title = "x coordinate of inspection point";
	else if (id == 'y_inspect') 	title = "y coordinate of inspection point";
	else if (id == 'dt1') 			title = "time since retarded wave origin";
	else if (id == 'dt2') 			title = "time until advanced wave origin";
	else if (id == 't1') 			title = "time of retarded wave origin";
	else if (id == 't2') 			title = "time of advanced wave origin";
	else if (id == 'x1') 			title = "x location of retarded wave origin";
	else if (id == 'x2')			title = "x location of advanced wave origin";
	else if (id == 'cycle1') 		title = "cycle of retarded wave";
	else if (id == 'cycle2') 		title = "cycle of advanced wave";
	else if (id == 'phase1') 		title = "phase of retarded wave [radians]";
	else if (id == 'phase2') 		title = "phase of advanced wave [radians]";
	else if (id == 'real1') 		title = "real amplitude of retarded wave";
	else if (id == 'real2') 		title = "real amplitude of advanced wave";
	else if (id == 't_part')		title = "time particle is at this location";
	else if (id == 'cycle1_part') 	title = "cycle of retarded wave";
	else if (id == 'cycle2_part') 	title = "cycle of advanced wave";
	else if (id == 'phase1_part') 	title = "phase of retarded wave [radians]";
	else if (id == 'phase2_part') 	title = "phase of advanced wave [radians]";
	else if (id == 'real1_part') 	title = "real amplitude of retarded wave";
	else if (id == 'real2_part') 	title = "real amplitude of advanced wave"
	$i(id).title = title;
}

function setTitles() // init dynamic titles
{
	setTitle('time');
	setTitle('v_over_c');
	setTitle('u_over_c');
	setTitle('gamma');
	setTitle('x_particle');
	setTitle('real');
	setTitle('r1');			setTitle('r2');
	setTitle('dx');			setTitle('dy');
	setTitle('x_inspect');	setTitle('y_inspect');
	setTitle('dt1');		setTitle('dt2');
	setTitle('t1');			setTitle('t2');
	setTitle('x1');			setTitle('x2');
	setTitle('t_part');
	setTitle('cycle1');		setTitle('cycle2');
	setTitle('phase1');		setTitle('phase2');
	setTitle('real1');		setTitle('real2');
	setTitle('cycle1_part');setTitle('cycle2_part');
	setTitle('phase1_part');setTitle('phase2_part');
	setTitle('real1_part');	setTitle('real2_part');
}

function showValue(event) {setValue(event.target.id);}
function showTitle(event) {setTitle(event.target.id);}

function titleValue(name) {$i(name).addEventListener("mouseenter",showValue); $i(name).addEventListener("mouseleave",showTitle);}

// dynamic titles to show full value with mouseenter while paused
titleValue('time');
titleValue('v_over_c');
titleValue('u_over_c');
titleValue('gamma');
titleValue('real');
titleValue('x_particle');
titleValue('r1');			titleValue('r2');
titleValue('dx');			titleValue('dy');
titleValue('x_inspect');	titleValue('y_inspect');
titleValue('dt1');			titleValue('dt2');
titleValue('t1');			titleValue('t2');
titleValue('x1');			titleValue('x2');
titleValue('t_part');
titleValue('cycle1');		titleValue('cycle2');
titleValue('phase1');		titleValue('phase2');
titleValue('real1');		titleValue('real2');
titleValue('cycle1_part');	titleValue('cycle2_part');
titleValue('phase1_part');	titleValue('phase2_part');
titleValue('real1_part');	titleValue('real2_part');

// ranges
$i('speed_range').addEventListener("input", speed_change);

function eventListeners(down,out,up)
{
	// radio input
	$i('forward_radio').addEventListener(up,        	forwardButton);
	$i('backward_radio').addEventListener(up,       	backwardButton);
	$i('stationary_radio').addEventListener(up,			stationaryButton);
	$i('particle_radio').addEventListener(up,       	particleButton);
	$i('de_Broglie_radio').addEventListener(up,			deBroglieButton);

	// spans
	$i('time_span').addEventListener(up,      			timeSpan);
	$i('t1').addEventListener(up,      					t1Span);
	$i('t2').addEventListener(up,      					t2Span);
	$i('v_over_c_span').addEventListener(up,      		v_over_cSpan);
	//$i('v_span').addEventListener(up,      				vSpan);
	$i('u_over_c_span').addEventListener(up,      		u_over_cSpan);
	//$i('u_span').addEventListener(up,      				uSpan);
	$i('gamma_span').addEventListener(up,      			gammaSpan);
	$i('particle_time').addEventListener(up,			particle_timeSpan);
	$i('derivation_span').addEventListener(up,			derivation);
  
  	// checkboxes as firstChild
  	$i('notation').addEventListener(up,        			toggleCheckbox);
	$i('retarded').addEventListener(up,					toggleCheckbox);
	$i('advanced').addEventListener(up,					toggleCheckbox);
	$i('dblslit_inspector').addEventListener(up,		toggleCheckbox);
	$i('point_inspector').addEventListener(up,			toggleInspector);
	$i('particle_inspector').addEventListener(up,		toggleInspector);

	// buttons
	$i('source_button').addEventListener(up,			sourceButton);
	$i('destination_button').addEventListener(up,		destinationButton);
	//$i('complex_button').addEventListener(up,			complexButton);
	//$i('real_button').addEventListener(up,			realButton);
	//$i('dblslit_button').addEventListener(up,		 	dblslitButton);
	$i('free_button').addEventListener(up,				freeButton);
	$i('zoom_out_button').addEventListener(down,      	zoom_out_down);
	$i('zoom_out_button').addEventListener(out,       	zoom_out_up);
	$i('zoom_out_button').addEventListener(up,        	zoom_out_up);
	$i('zoom_zero_button').addEventListener(up,       	zoom_zero);
	$i('zoom_in_button').addEventListener(down,       	zoom_in_down);
	$i('zoom_in_button').addEventListener(out,        	zoom_in_up);
	$i('zoom_in_button').addEventListener(up,         	zoom_in_up);
	$i('slower_button').addEventListener(up,          	slowerButton);
	$i('faster_button').addEventListener(up,          	fasterButton);
	$i('reset_button').addEventListener(up,           	reset);
	$i('exit_button').addEventListener(up,            	exit);
	$i('pause_resume_button').addEventListener(up,    	pause_resumeButton);
	$i('stepbackward_button').addEventListener(down,	stepbackward_down);
	$i('stepbackward_button').addEventListener(out,   	stepbackward_up);
	$i('stepbackward_button').addEventListener(up,    	stepbackward_up);
	$i('stepforward_button').addEventListener(down,   	stepforward_down);
	$i('stepforward_button').addEventListener(out,    	stepforward_up);
	$i('stepforward_button').addEventListener(up,     	stepforward_up);
	$i('return_from_description').addEventListener(up,  return_to_start);
	$i('return_from_UI').addEventListener(up,          	return_to_start);
	$i('description_button').addEventListener(up,     	description);
	$i('return_from_derivation').addEventListener(up,	return_from_derivation);
	//$i('FAQ_button').addEventListener(up,             FAQ);
	$i('UI_button').addEventListener(up,              	UI);
}

if ('onpointerdown' in window) eventListeners("pointerdown","pointerout","pointerup");
else if ('ontouchstart' in window) eventListeners("touchstart","touchmove","touchend");
else eventListeners("mousedown","mouseout","mouseup");

        </script>
    </body>
</html>
